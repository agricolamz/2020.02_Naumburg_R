[
["index.html", "Polish Language(s) and Digital Humanities Using R 1 Prerequisites", " Polish Language(s) and Digital Humanities Using R G. Moroz 2020 1 Prerequisites Before the classes I would like to ask you to follow the instructions mentioned below to prepare your device for the class work: install R from the following link: https://cloud.r-project.org/ install RStudio from the following link: https://rstudio.com/products/rstudio/download/#download (FREE version, no need to pay!) after the installation run the RStudio program, type 2+2, and press Enter. If you see something like this, then you are well prepared for classes. Go to the https://rstudio.cloud/ website and sign up there. This is optional, but it will be a backup version, if something will not work on your computer. Special thanks to Helena Link for the workshop orgonisation and for correcting typos in this text. "],
["intro.html", "2 Introduction to R and RStudio 2.1 Introduction 2.2 Introduction to RStudio 2.3 R as a calculator 2.4 Comments 2.5 Functions 2.6 Variables 2.7 Vector 2.8 Packages 2.9 Dataframe (tibble) 2.10 Data import 2.11 Rmarkdown", " 2 Introduction to R and RStudio 2.1 Introduction 2.1.1 Why data science? Data science is a new field that is actively developing lately. This field merges computer science, mathematics, statistics, and it is hard to say how much science in data science. In many scientific fields a new data science paradigm arises and even forms a new sub-field: Bioinformatics Crime data analysis Digital humanities Data journalism Data driven medicine ‚Ä¶ There are a lot of new books ‚ÄúData Science for ‚Ä¶‚Äù: psychologists (Hansj√∂rg 2019) immunologists (Thomas and Pallett 2019) business (Provost and Fawcett 2013) public policy (Brooks and Cooper 2013) fraud detection (Baesens, Van Vlasselaer, and Verbeke 2015) ‚Ä¶ Data scientists need to be able to: gather data transform data visualize data create a statistical model based on data share and represent the results of this work organize the whole workflow in a reproducible way 2.1.2 Why R? R (R Core Team 2019) is a programming language with a big infrastructure of packages that helps to work in different fields of science and computer technology. There are several alternatives: Python (VanderPlas 2016; Grus 2019) Julia (Bezanson et al. 2017) bash (Janssens 2014) java (Brzustowicz 2017) ‚Ä¶ You can find some R answers here: R for data science (Wickham 2016), it is online R community stackoverflow any search engine you use ‚Ä¶ 2.2 Introduction to RStudio R is the programming language. RStudio is the most popular IDE (Integrated Development Environment) for R language. When you open RStudio for the first time you can see something like this: When you press button at the top of the left window you will be able to see all four panels of RStudio. 2.3 R as a calculator Lets first start with the calculator. Press in R console 2+9 ## [1] 11 50*(9-20) ## [1] -550 3^3 ## [1] 27 9^0.5 ## [1] 3 9+0.5 ## [1] 9.5 9+.5 ## [1] 9.5 pi ## [1] 3.141593 Remainder after division 10 %% 3 ## [1] 1 So you are ready to solve some really hard equations (round it four decimal places): \\[\\frac{\\pi+2}{2^{3-\\pi}}\\] üìã list of hints ‚û° üëÅ Are you sure that you rounded the result? ‚û° I expect the answer to be rounded to four decimal places: 0.87654321 becomes 0.8765. üëÅ Are you sure you didn‚Äôt get into the brackets trap? ‚û° Even though there isn‚Äôt any brackets in the mathematical notation, you need to add them in R, otherwise the operation order will be wrong. 2.4 Comments Any text after a hash # within the same line is considered a comment. 2+2 # it is four ## [1] 4 # you can put any comments here 3+3 ## [1] 6 2.5 Functions The most important part of R is functions: here are some of them: sqrt(4) ## [1] 2 abs(-5) ## [1] 5 sin(pi/2) ## [1] 1 cos(pi) ## [1] -1 sum(2, 3, 9) ## [1] 14 prod(5, 3, 9) ## [1] 135 sin(cos(pi)) ## [1] -0.841471 Each function has a name and zero or more arguments. All arguments of the function should be listed in parenthesis and separated by comma: pi ## [1] 3.141593 round(pi, 2) ## [1] 3.14 Each function‚Äôs argument has its own name and serial number. If you use names of the function‚Äôs arguments, you can put them in any order. If you do not use names of the function‚Äôs arguments, you should put them according the serial number. round(x = pi, digits = 2) ## [1] 3.14 round(digits = 2, x = pi) ## [1] 3.14 round(x = pi, d = 2) ## [1] 3.14 round(d = 2, x = pi) ## [1] 3.14 round(pi, 2) ## [1] 3.14 round(2, pi) # this is not the same as all previous! ## [1] 2 There are some functions without any arguments, but you still should use parenthesis: Sys.Date() # correct ## [1] &quot;2020-02-22&quot; Sys.Date # wrong ## function () ## as.Date(as.POSIXlt(Sys.time())) ## &lt;bytecode: 0x623fcce1c110&gt; ## &lt;environment: namespace:base&gt; Each function in R is documented. You can read its documentation typing a question mark before the function name: ?Sys.Date Explore the function log() and calculate the following logarithm: \\[\\log_3(3486784401)\\] üìã list of hints ‚û° üëÅ A-a-a! I don‚Äôt remember anything about logarithms‚Ä¶ ‚û° The logarithm is the inverse function to exponentiation. That means the logarithm of a given number x is the exponent to which another fixed number, the base b, must be raised, to produce that number x. \\[10^n = 1000,\\text{ what is n?}\\] \\[n = \\log_{10}(1000)\\] üëÅ What does this small 3 in the task mean? ‚û° This is the base of the logarithm. So the task is: what is the exponent to which another fixed number, the base 3, must be raised, to produce that number 3486784401. 2.6 Variables Everything in R can be stored in a variable: x &lt;- 5 + 6 As a result, no output in the Console, and a new variable x appear in the Environment window. From now on I can use this new variable: x + x ## [1] 22 sum(x, x, 7) ## [1] 29 All those operations don‚Äôt change the variable value. In order to change the variable value you need to make a new assignment: x &lt;- 5 + 6 + 7 The fast way for creating &lt;- in RStudio is to press Alt - on your keyboard. It is possible to use equal sign = for assignment operation, but the recommendations are to use arrow &lt;- for the assignment, and equal sign = for giving arguments‚Äô value inside the functions. For removing vector you need to use the function rm(): rm(x) x ## Error in eval(expr, envir, enclos): object &#39;x&#39; not found 2.6.1 Variable comparison It is possible to compare different variables x &lt;- 18 x &gt; 18 ## [1] FALSE x &gt;= 18 ## [1] TRUE x &lt; 100 ## [1] TRUE x &lt;= 18 ## [1] TRUE x == 18 ## [1] TRUE x != 18 ## [1] FALSE Operator ! can work by itself changing logical values into reverse: !TRUE ## [1] FALSE !FALSE ## [1] TRUE 2.6.2 Variable types There are several types of variables in R. In this course the only important types will be double (all numbers), character (or strings), and logical: x &lt;- 2+3 typeof(x) ## [1] &quot;double&quot; y &lt;- &quot;Cze≈õƒá&quot; typeof(y) ## [1] &quot;character&quot; z &lt;- TRUE typeof(z) ## [1] &quot;logical&quot; 2.7 Vector An R object that contains multiple values of the same type is called vector. It could be created with the command c(): c(3, 0, pi, 23.4, -53) ## [1] 3.000000 0.000000 3.141593 23.400000 -53.000000 c(&quot;Krak√≥w&quot;, &quot;Warszawa&quot;, &quot;Cieszyn&quot;) ## [1] &quot;Krak√≥w&quot; &quot;Warszawa&quot; &quot;Cieszyn&quot; c(FALSE, FALSE, TRUE) ## [1] FALSE FALSE TRUE a &lt;- c(2, 3, 4) b &lt;- c(5, 6, 7) c(a, b) ## [1] 2 3 4 5 6 7 For the number sequences there is an easy way: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 3:-5 ## [1] 3 2 1 0 -1 -2 -3 -4 -5 From now on you can understand that everything we have seen before is a vector of length one. That is why there is [1] in all outputs: it is just an index of elements in a vector. Have a look here: 1:60 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ## [51] 51 52 53 54 55 56 57 58 59 60 60:1 ## [1] 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 ## [26] 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 ## [51] 10 9 8 7 6 5 4 3 2 1 There is also a function seq() for creation of arithmetic progressions: 1:20 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 seq(from = 1, to = 20, by = 1) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 seq(from = 2, to = 100, by = 13) ## [1] 2 15 28 41 54 67 80 93 Use the argument length.out of function seq() and create an arithmetic sequence from \\(\\pi\\) to \\(2\\pi\\) of length 50. There are also some built-in vectors: letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; month.abb ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; 2.7.1 Vector coercion Vectors are R objects that contain multiple values of the same type. But what if we merged together different types? c(1, &quot;34&quot;) ## [1] &quot;1&quot; &quot;34&quot; c(1, TRUE) ## [1] 1 1 c(TRUE, &quot;34&quot;) ## [1] &quot;TRUE&quot; &quot;34&quot; It is clear that there is a hierarchy: strings &gt; double &gt; logical. It is not universal across different programming languages. It doesn‚Äôt correspond to the amount of values of particular type: c(1, 2, 3, &quot;34&quot;) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;34&quot; c(1, TRUE, FALSE, FALSE) ## [1] 1 1 0 0 The same story could happen during other operations: 5+TRUE ## [1] 6 2.7.2 Vector operations All operations, that we discussed earlier, could be done with vectors of the same length: 1:5 + 6:10 ## [1] 7 9 11 13 15 1:5 - 6:10 ## [1] -5 -5 -5 -5 -5 1:5 * 6:10 ## [1] 6 14 24 36 50 There are operations where the vector of any length and vector of length one is involved: 1:5 + 7 ## [1] 8 9 10 11 12 1:5 - 7 ## [1] -6 -5 -4 -3 -2 1:5 / 7 ## [1] 0.1428571 0.2857143 0.4285714 0.5714286 0.7142857 There are a lot of functions in R that are vectorised. That means that applying this function to a vector is the same as applying this function to each element of the vector: sin(1:5) ## [1] 0.8414710 0.9092974 0.1411200 -0.7568025 -0.9589243 sqrt(1:5) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 abs(-5:3) ## [1] 5 4 3 2 1 0 1 2 3 2.7.3 Indexing vectors How to get some value or banch of values from a vector? You need to index them: x &lt;- c(3, 0, pi, 23.4, -53) y &lt;- c(&quot;Krak√≥w&quot;, &quot;Warszawa&quot;, &quot;Cieszyn&quot;) x[4] ## [1] 23.4 y[2] ## [1] &quot;Warszawa&quot; It is possible to have a vector as index: x[1:2] ## [1] 3 0 y[c(1, 3)] ## [1] &quot;Krak√≥w&quot; &quot;Cieszyn&quot; It is possible to index something that you do not want to see in the result: y[-2] ## [1] &quot;Krak√≥w&quot; &quot;Cieszyn&quot; x[-c(1, 4)] ## [1] 0.000000 3.141593 -53.000000 It is possible to have other variables as an index z &lt;- c(3, 2) x[z] ## [1] 3.141593 0.000000 y[z] ## [1] &quot;Cieszyn&quot; &quot;Warszawa&quot; It is possible to index with a logical vector: x[c(TRUE, FALSE, TRUE, TRUE, FALSE)] ## [1] 3.000000 3.141593 23.400000 That means that we could use TRUE/FALSE-vector produced by comparison: x[x &gt; 2] ## [1] 3.000000 3.141593 23.400000 It works because x &gt; 2 is a vector of logical values: x &gt; 2 ## [1] TRUE FALSE TRUE TRUE FALSE It is possible to use ! operator here changing all TRUE values to FALSE and vice versa. x[!(x &gt; 2)] ## [1] 0 -53 How many elements in the vector g if expression g[pi &lt; 1000] does not return an error? 2.7.4 NA Sometimes there are some missing values in the data, so it is represented with NA NA ## [1] NA c(1, NA, 9) ## [1] 1 NA 9 c(&quot;Krak√≥w&quot;, NA, &quot;Cieszyn&quot;) ## [1] &quot;Krak√≥w&quot; NA &quot;Cieszyn&quot; c(TRUE, FALSE, NA) ## [1] TRUE FALSE NA It is possible to check, whether there are missing values or not x &lt;- c(&quot;Krak√≥w&quot;, NA, &quot;Cieszyn&quot;) y &lt;- c(&quot;Krak√≥w&quot;, &quot;Warszawa&quot;, &quot;Cieszyn&quot;) is.na(x) ## [1] FALSE TRUE FALSE is.na(y) ## [1] FALSE FALSE FALSE Some functions doesn‚Äôt work with vecotors that contain missed values, so you need to add argument na.rm = TRUE: x &lt;- c(1, NA, 9, 5) mean(x) ## [1] NA mean(x, na.rm = TRUE) ## [1] 5 min(x, na.rm = TRUE) ## [1] 1 max(x, na.rm = TRUE) ## [1] 9 median(x, na.rm = TRUE) ## [1] 5 range(x, na.rm = TRUE) ## [1] 1 9 2.8 Packages The most important and useful part of R is hidden in its packages. Everything that we discussed so far is basic R functionality invented back in 1979. Since then a lot of different things changed, so all new practices for data analysis, visualisation and manipulation are packed in packages. During our class we will learn the most popular ‚Äúdialect‚Äù of R called tidyverse. In order to install packages you need to use a command. Let‚Äôs install the tidyverse package: install.packages(&quot;tidyverse&quot;) For today we also will need the readxl package: install.packages(&quot;readxl&quot;) After you have downloaded packages nothing will change. You can not use any fucntionality from packages unless you load the package with the library() function: library(&quot;tidyverse&quot;) ## ‚îÄ‚îÄ Attaching packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 1.3.0 ‚îÄ‚îÄ ## ‚úì ggplot2 3.2.1 ‚úì purrr 0.3.3 ## ‚úì tibble 2.1.3 ‚úì dplyr 0.8.3 ## ‚úì tidyr 1.0.0 ‚úì stringr 1.4.0 ## ‚úì readr 1.3.1 ‚úì forcats 0.4.0 ## ‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() Not loading a package is the most popular mistake of my students. So remember: install.packages(\"...\") is like you are buying a screwdriver set; library(\"...\") is like you are starting to use your screwdriver. For the further lectures we will need tidyverse package. Please install tidyverse package and load it. 2.8.1 tidyverse The tidyverse is a set of packages: tibble, for tibbles, a modern re-imagining of data frames ‚Äî analogue of tables in R readr, for data import dplyr, for data manipulation tidyr, for data tidying (we will discuss it later today) ggplot2, for data visualisation purrr, for functional programming 2.9 Dataframe (tibble) A data frame is a collection of variables of the same number of rows with unique row names. Here is an example dataframe with the Tomm Moore filmography: moore_filmography &lt;- tibble(title = c(&quot;The Secret of Kells&quot;, &quot;Song of the Sea&quot;, &quot;Kahlil Gibran&#39;s The Prophet&quot;, &quot;The Breadwinner&quot;, &quot;Wolfwalkers&quot;), year = c(2009, 2014, 2014, 2017, 2020), director = c(TRUE, TRUE, TRUE, FALSE, TRUE)) moore_filmography There are a lot of built-in dataframes: mtcars iris You can find information about them: ?mtcars ?iris Dataframe consists of vectors that could be called using $ sign: moore_filmography$year ## [1] 2009 2014 2014 2017 2020 moore_filmography$title ## [1] &quot;The Secret of Kells&quot; &quot;Song of the Sea&quot; ## [3] &quot;Kahlil Gibran&#39;s The Prophet&quot; &quot;The Breadwinner&quot; ## [5] &quot;Wolfwalkers&quot; It is possible to add a vector to an existing dataframe: moore_filmography$producer &lt;- c(TRUE, TRUE, FALSE, TRUE, TRUE) moore_filmography There are some useful functions that tell you somethig about a dataframe: nrow(moore_filmography) ## [1] 5 ncol(moore_filmography) ## [1] 4 summary(moore_filmography) ## title year director producer ## Length:5 Min. :2009 Mode :logical Mode :logical ## Class :character 1st Qu.:2014 FALSE:1 FALSE:1 ## Mode :character Median :2014 TRUE :4 TRUE :4 ## Mean :2015 ## 3rd Qu.:2017 ## Max. :2020 str(moore_filmography) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 5 obs. of 4 variables: ## $ title : chr &quot;The Secret of Kells&quot; &quot;Song of the Sea&quot; &quot;Kahlil Gibran&#39;s The Prophet&quot; &quot;The Breadwinner&quot; ... ## $ year : num 2009 2014 2014 2017 2020 ## $ director: logi TRUE TRUE TRUE FALSE TRUE ## $ producer: logi TRUE TRUE FALSE TRUE TRUE We will work exclusively with dataframes. But it is not the only data structure in R. How many rows are in the iris dataframe? How many columns are in the mtcars dataframe? 2.9.1 Indexing dataframes Since dataframes are two-dimensional objects it is possible to index its rows and columns. Rows are the first index, columns are the second index: moore_filmography[3, 2] moore_filmography[3,] moore_filmography[,2] moore_filmography[,1:2] moore_filmography[,-3] moore_filmography[,-c(1:2)] moore_filmography[,&quot;year&quot;] moore_filmography[,c(&quot;title&quot;, &quot;year&quot;)] moore_filmography[moore_filmography$year &gt; 2014,] 2.10 Data import 2.10.1 .csv files A .csv files (comma-separated values) is a delimited text file that uses a comma (or other delemeters such as tabulation or semicolon) to separate values. It is broadly used bacause it is possible to parse such a file using computers and people can edit it in the Office programs (Microsoft Excel, LibreOffice Calc, Numbers on Mac). Here is our moore_filmography dataset in the .csv format: title,year,director,producer The Secret of Kells,2009,TRUE,TRUE Song of the Sea,2014,TRUE,TRUE Kahlil Gibran&#39;s The Prophet,2014,TRUE,FALSE The Breadwinner,2017,FALSE,TRUE Wolfwalkers,2020,TRUE,TRUE Let‚Äôs create a variable with this file: our_csv &lt;- &quot;title,year,director,producer The Secret of Kells,2009,TRUE,TRUE Song of the Sea,2014,TRUE,TRUE Kahlil Gibran&#39;s The Prophet,2014,TRUE,FALSE The Breadwinner,2017,FALSE,TRUE Wolfwalkers,2020,TRUE,TRUE&quot; Now we are ready to use read_csv() function: read_csv(our_csv) It is also possible to read files from your computer. Download this file on your computer (press Ctrl S or Cmd S) and read into R: read_csv(&quot;C:/path/to/your/file/moore_filmography.csv&quot;) It is also possible to read files from the Internet: read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020.02_Naumburg_R/master/data/moore_filmography.csv&quot;) ## Parsed with column specification: ## cols( ## title = col_character(), ## year = col_double(), ## director = col_logical(), ## producer = col_logical() ## ) Because of the 2019‚Äì20 Wuhan coronavirus outbreak the city of Wuhan is on media everywhere. In Russian for some reason Wuhan is sometimes masculine and sometimes it is feminin. I looked into other Slavic languages and recorded obtained data into the .csv file. Download this files to R. What variables does it have? All file manipulations in R are somehow connected with space on your computer via working directory. You can get information about your current working directory using getwd() function. You can change your working directory using setwd() function. If a file you want to read is in the working directory you don‚Äôt need to write the whole path to file: read_csv(&quot;moore_filmography.csv&quot;) The same simple function will create your .csv file: write_csv(moore_filmography, &quot;moore_filmography_v2.csv&quot;) Sometimes reading .csv files into Microsoft Excel is complicated, please follow the following instructions. 2.10.2 .xls and .xlsx files There is a package readxl that allows to open and save .xsl and .xslx files. Install and load the package: library(readxl) Here is a test file. Download it to your computer and put it to your working directory: read_xlsx(&quot;moore_filmography.xlsx&quot;) .xls and .xlsx files could have multiple tables on different sheets: read_xlsx(&quot;moore_filmography.xlsx&quot;, sheet = &quot;iris&quot;) 2.11 Rmarkdown If you press Ctrl S or Cmd S then you will save your script. There is also another useful type of coding in R: rmarkown. First install this package: install.packages(&quot;rmarkdown&quot;) Then it will be possible to create a new file: File &gt; New File &gt; R Markdown.... Press OK in the following menu and you will get the template of your R Markdown file. You can modify it, then press and the result file will be created in your working directory. rmarkdown package is a really popular and well developed package that creates output into: markdown html docx pdf beamer presentation pptx presentation epub ‚Ä¶ multiple templates for different scientific journals (package rticsles and papaja) ‚Ä¶ References "],
["dplyr.html", "3 Data manipulation: dplyr 3.1 Data 3.2 dplyr 3.3 Merging dataframes 3.4 tidyr package", " 3 Data manipulation: dplyr First, load the library: library(tidyverse) 3.1 Data In this chapter we will use the following datasets. 3.1.1 Misspelling dataset I gathered this dataset after some manipulations with data from The Gyllenhaal Experiment by Russell Goldenberg and Matt Daniels for pudding. They analized mistakes in spellings of celebrities during the searching process. misspellings &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020.02_Naumburg_R/master/data/misspelling_dataset.csv&quot;) ## Parsed with column specification: ## cols( ## correct = col_character(), ## spelling = col_character(), ## count = col_double() ## ) misspellings There are the following variables in this dataset: correct ‚Äî correct spelling spelling ‚Äî user‚Äôs spelling count ‚Äî number of cases of user‚Äôs spelling 3.1.2 diamonds diamonds ‚Äî is the dataset built-in in the tidyverse package. diamonds ?diamonds 3.2 dplyr Here and here is a cheatsheet on dplyr. 3.2.1 filter() This function filters rows under some conditions. How many wrong spellings were used by less then 10 users? misspellings %&gt;% filter(count &lt; 10) %&gt;% it is pipe (hot key is Ctrl Shift M). It allows to chain operations, putting the output of one function into the input of another: sort(sqrt(abs(sin(1:22))), decreasing = TRUE) ## [1] 0.9999951 0.9952926 0.9946649 0.9805088 0.9792468 0.9554817 0.9535709 ## [8] 0.9173173 0.9146888 0.8699440 0.8665952 0.8105471 0.8064043 0.7375779 ## [15] 0.7325114 0.6482029 0.6419646 0.5365662 0.5285977 0.3871398 0.3756594 ## [22] 0.0940814 1:22 %&gt;% sin() %&gt;% abs() %&gt;% sqrt() %&gt;% sort(., decreasing = TRUE) # why do we need a dot here? ## [1] 0.9999951 0.9952926 0.9946649 0.9805088 0.9792468 0.9554817 0.9535709 ## [8] 0.9173173 0.9146888 0.8699440 0.8665952 0.8105471 0.8064043 0.7375779 ## [15] 0.7325114 0.6482029 0.6419646 0.5365662 0.5285977 0.3871398 0.3756594 ## [22] 0.0940814 Pipes that are used in tidyverse are from the package magrittr. Sometimes pipe could work not well with functions outside the tidyverse. So filter() function returns rows with matching conditions: misspellings %&gt;% filter(count &lt; 10) It is possible to use multiple conditions. How many wrong spellings of Deschanel were used by less then 10 users? misspellings %&gt;% filter(count &lt; 10, correct == &quot;deschanel&quot;) It is possible to use OR conditions. How many wrong spellings were used by less then 10 OR more then 500 users? misspellings %&gt;% filter(count &lt; 10 | count &gt; 500) 3.2.2 slice() This function filters rows by its index. misspellings %&gt;% slice(3:7) 3.2.3 select() This functions for choosing variables from a dataframe. diamonds %&gt;% select(8:10) diamonds %&gt;% select(color:price) diamonds %&gt;% select(-carat) diamonds %&gt;% select(-c(carat, cut, x, y, z)) diamonds %&gt;% select(cut, depth, price) 3.2.4 arrange() This function orders rows in a dataframe (numbers ‚Äî by order, strings ‚Äî alphabetically). misspellings %&gt;% arrange(count) diamonds %&gt;% arrange(desc(carat), price) diamonds %&gt;% arrange(-carat, price) 3.2.5 distinct() This function returns only unique rows from an input dataframe. misspellings %&gt;% distinct(correct) misspellings %&gt;% distinct(spelling) diamonds %&gt;% distinct(color, cut) In built-in dataset starwars filter those characters that are higher then 180 (height) and weigh less then 80 (mass). How many unique names of their homeworlds (homeworld) is there? 3.2.6 mutate() This function creates new variables. misspellings %&gt;% mutate(misspelling_length = nchar(spelling), id = 1:n()) Create a variable with body mass index Body mass index: \\(\\frac{mass}{height^2}\\) for all characters from starwars dataset. How many charachters have obesity (have body mass index greater 30)? (Don‚Äôt forget to convert height from centimetres to metres). 3.2.7 group_by(...) %&gt;% summarise(...) This function allows to group variables by some columns and get some descriptive statistics (maximum, minimum, last value, first value, mean, median etc.) misspellings %&gt;% summarise(min(count), mean(count)) misspellings %&gt;% group_by(correct) %&gt;% summarise(mean(count)) misspellings %&gt;% group_by(correct) %&gt;% summarise(my_mean = mean(count)) If you need to calculate number of cases, use the function n() in summarise() or the count() function: misspellings %&gt;% group_by(correct) %&gt;% summarise(n = n()) misspellings %&gt;% count(correct) It is even possible to sort the result, using sort argument: misspellings %&gt;% count(correct, sort = TRUE) In case you don‚Äôt want to have any summary, but an additional column, just replace summarise() with mutate() misspellings %&gt;% group_by(correct) %&gt;% mutate(my_mean = mean(count)) Here is a scheme: In the starwars dataset create a variable that contains mean height value for each species. 3.3 Merging dataframes 3.3.1 bind_... This is a family of functions that make it possible to merge dataframes together: my_tbl &lt;- tibble(a = c(1, 5, 2), b = c(&quot;e&quot;, &quot;g&quot;, &quot;s&quot;)) Here is how to merge two datasets by row: my_tbl %&gt;% bind_rows(my_tbl) In case there is an absent column, values will be filled with NA: my_tbl %&gt;% bind_rows(my_tbl[,-1]) In order to merge dataframes by column you need another function: my_tbl %&gt;% bind_cols(my_tbl) In case there is an absent row, this function will return an error: my_tbl %&gt;% bind_cols(my_tbl[-1,]) ## Error: Argument 2 must be length 3, not 2 3.3.2 .._join() These functions allow to merge different datasets by some column (or columns in common). languages &lt;- data_frame( languages = c(&quot;Selkup&quot;, &quot;French&quot;, &quot;Chukchi&quot;, &quot;Polish&quot;), countries = c(&quot;Russia&quot;, &quot;France&quot;, &quot;Russia&quot;, &quot;Poland&quot;), iso = c(&quot;sel&quot;, &quot;fra&quot;, &quot;ckt&quot;, &quot;pol&quot;) ) ## Warning: `data_frame()` is deprecated, use `tibble()`. ## This warning is displayed once per session. languages country_population &lt;- data_frame( countries = c(&quot;Russia&quot;, &quot;Poland&quot;, &quot;Finland&quot;), population_mln = c(143, 38, 5)) country_population inner_join(languages, country_population) ## Joining, by = &quot;countries&quot; left_join(languages, country_population) ## Joining, by = &quot;countries&quot; right_join(languages, country_population) ## Joining, by = &quot;countries&quot; anti_join(languages, country_population) ## Joining, by = &quot;countries&quot; anti_join(country_population, languages) ## Joining, by = &quot;countries&quot; full_join(country_population, languages) ## Joining, by = &quot;countries&quot; 3.4 tidyr package Here is a dataset with the number of speakers of some language of India according the census 2001 (data from Wikipedia): langs_in_india_short &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020.02_Naumburg_R/master/data/languages_in_india.csv&quot;) ## Parsed with column specification: ## cols( ## language = col_character(), ## n_L1_sp = col_double(), ## n_L2_sp = col_double(), ## n_L3_sp = col_double(), ## n_all_sp = col_double() ## ) Wide format langs_in_india_short Long format Wide format ‚Üí Long format: tidyr::pivot_longer() langs_in_india_short %&gt;% pivot_longer(names_to = &quot;type&quot;, values_to = &quot;n_speakers&quot;, n_L1_sp:n_all_sp)-&gt; langs_in_india_long langs_in_india_long Long format ‚Üí Wide format: tidyr::pivot_wider() langs_in_india_long %&gt;% pivot_wider(names_from = &quot;type&quot;, values_from = &quot;n_speakers&quot;)-&gt; langs_in_india_short langs_in_india_short 3.4.1 Tidy data You can represent the same underlying data in multiple ways. The whole tidyverse phylosophy built upon the tidy datasets, that are datasets where: Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. Here is data, that contains information about villages of Daghestan in .xlsx format. The data is separated by different sheets and contains the following variables (data obtained from different sources, so they have suffixes _s1 ‚Äì first source and _s2 ‚Äì second source): id_s1 ‚Äì (s1) identification number from first source; name_1885 ‚Äì (s1) name of the village according the 1885 census census_1885 ‚Äì (s1) population according the 1885 census name_1895 ‚Äì (s1) name of the village according the 1895 census census_1895 ‚Äì (s1) population according the 1895 census name_1926 ‚Äì (s1) name of the village according the 1926 census census_1926 ‚Äì (s1) population according the 1926 census name_2010 ‚Äì (s1) name of the village according the 2010 census census_2010 ‚Äì (s1) population according the 2010 census language_s1 ‚Äì (s1) language name according the first source name_s2 ‚Äì (s2) village name according the second source language_s2 ‚Äì (s2) language name according the second source Lat ‚Äì (s2) latitude Lon ‚Äì (s2) longitude elevation ‚Äì (s2) altitude First, merge all sheets fromt the .xlsx file: Second, caclulate how many times the language name is the same in both sources. Third, calculate mean altitude for languages from the first source. Which is the highest? Fourth, calculate the population for languages from the second source in each census. Show the values obtained for the Lak language: "],
["ggplot2.html", "4 Data visualisation: ggplot2 4.1 Why visualising data? 4.2 Basic ggplot2 4.3 Faceting", " 4 Data visualisation: ggplot2 library(&quot;tidyverse&quot;) 4.1 Why visualising data? 4.1.1 The Anscombe‚Äôs Quartet In Anscombe, F. J. (1973). ‚ÄúGraphs in Statistical Analysis‚Äù there was the following dataset: quartet &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020.02_Naumburg_R/master/data/anscombe.csv&quot;) quartet quartet %&gt;% group_by(dataset) %&gt;% summarise(mean_X = mean(x), mean_Y = mean(y), sd_X = sd(x), sd_Y = sd(y), cor = cor(x, y), n_obs = n()) %&gt;% select(-dataset) %&gt;% round(2) Let‚Äôs visualise those datasets: 4.1.2 The DataSaurus In Matejka and Fitzmaurice (2017) ‚ÄúSame Stats, Different Graphs‚Äù there are the following datasets: datasaurus &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020.02_Naumburg_R/master/data/datasaurus.csv&quot;) datasaurus And‚Ä¶ all discriptive statistics are the same! datasaurus %&gt;% group_by(dataset) %&gt;% summarise(mean_X = mean(x), mean_Y = mean(y), sd_X = sd(x), sd_Y = sd(y), cor = cor(x, y), n_obs = n()) %&gt;% select(-dataset) %&gt;% round(1) 4.2 Basic ggplot2 ggplot2 is a modern tool for data visualisation. There are a lot of extentions for ggplot2. There is also a cheatsheet on ggplot2. There is also a whole book about ggplot2 (Wickham 2016). Every ggplot2 plot has three key components: data, A set of aesthetic mappings between variables in the data and visual properties, and At least one layer which describes how to render each observation. Layers are usually created with a geom_...() function. 4.2.1 Scatterplot I downloaded a Polish dictionary from here. I removed all abbreviations and proper names and took only one form from the paradigm. After all this I calculated the number of syllables (simply by counting vowels, combinations of i and other vowels I counted as one), number of symbols in each word and extracted the first letter. Here is the result dataset. Download this dataset to the variable polish_dictionary. How many words are there? So this data could be visualised using the following code: ggplot2 ggplot(data = polish_dictionary, aes(x = n_char, y = n_vowels)) + geom_point() dplyr and ggplot2 polish_dictionary %&gt;% ggplot(aes(x = n_char, y = n_vowels))+ geom_point() 4.2.1.1 Layers All commands in ggplot2 are separated by + sign (author of the package, Hadley Wickham, deeply regrets that it is not %&gt;%), but their order matters: polish_dictionary %&gt;% ggplot(aes(n_char, n_vowels))+ geom_point()+ geom_smooth() polish_dictionary %&gt;% ggplot(aes(n_char, n_vowels))+ geom_smooth()+ geom_point() 4.2.1.2 aes() Since every ggplot2 plot has data as a key component there is a function aes() that maps variables from dataframe into visual properties of the graph. There is a simple rule: If values are from dataframe put them into aes(), otherwise ‚Äî don‚Äôt. polish_dictionary %&gt;% ggplot(aes(n_char, n_vowels, color = first_letter))+ geom_point() polish_dictionary %&gt;% ggplot(aes(n_char, n_vowels))+ geom_point(color = &quot;green&quot;) polish_dictionary %&gt;% ggplot(aes(n_char, n_vowels))+ geom_point(aes(color = first_letter)) There are some other possibilities to mark categories: with shape argument polish_dictionary %&gt;% filter(first_letter == &quot;a&quot; | first_letter == &quot;i&quot; | first_letter == &quot;u&quot;) %&gt;% ggplot(aes(n_char, n_vowels, shape = first_letter))+ geom_point() with label argument and geom_text() polish_dictionary %&gt;% filter(first_letter == &quot;a&quot; | first_letter == &quot;i&quot; | first_letter == &quot;u&quot;) %&gt;% ggplot(aes(n_char, n_vowels, label = first_letter))+ geom_text() with opacity argument polish_dictionary %&gt;% filter(first_letter == &quot;a&quot; | first_letter == &quot;i&quot; | first_letter == &quot;u&quot;) %&gt;% ggplot(aes(n_char, n_vowels))+ geom_point(alpha = 0.1) Sometimes annotations overlap: polish_dictionary %&gt;% slice(8400:8450) %&gt;% # lets pick 50 words from our dictionary ggplot(aes(n_char, n_vowels, label = word))+ geom_text() Then it is better to use geom_text_repel() from the ggrepel library (do not forget to download it using install.packages(\"ggrepel\")): library(&quot;ggrepel&quot;) polish_dictionary %&gt;% slice(8400:8450) %&gt;% ggplot(aes(n_char, n_vowels, label = word))+ geom_text_repel() It looks better, when you add some points: polish_dictionary %&gt;% slice(8400:8450) %&gt;% ggplot(aes(n_char, n_vowels, label = word))+ geom_text_repel()+ geom_point() 4.2.1.3 Annotate labels, axis, caption etc. polish_dictionary %&gt;% slice(8400:8450) %&gt;% ggplot(aes(n_char, n_vowels, label = word))+ geom_text_repel()+ geom_point()+ labs(x = &quot;number of characters&quot;, y = &quot;number of vowels&quot;, title = &quot;Correlation of number of characters and vowels&quot;, subtitle = &quot;data from sjp.pl&quot;, caption = &quot;this graph is created with ggplot2&quot;) Download this dataset and create a scatterplot. What is there? 4.2.2 Barplots The same data can be aggregated and non-aggregated: misspelling &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/misspelling_dataset.csv&quot;) misspelling variable spelling is aggregated: for each value of speeling variable there is a corresponding value in count variable. variable correct is non-aggregated: there is no any variable associated with counts of correct variable In order to create a bar plot from aggregated data you need to use geom_col(): misspelling %&gt;% slice(1:20) %&gt;% ggplot(aes(spelling, count))+ geom_col() Lets flip axes: misspelling %&gt;% slice(1:20) %&gt;% ggplot(aes(spelling, count))+ geom_col()+ coord_flip() In order to create a bar plot from aggregated data you need to use geom_bar(): misspelling %&gt;% ggplot(aes(correct))+ geom_bar() Lets flip axes: misspelling %&gt;% ggplot(aes(correct))+ geom_bar()+ coord_flip() Non-aggregated data could be transformed into aggregated misspelling %&gt;% count(correct) Aggregated data could be transformed into non-aggregated misspelling %&gt;% uncount(count) Coloring bars actually should be done with fill argument. Compare: misspelling %&gt;% ggplot(aes(correct))+ geom_bar(color = &quot;navy&quot;)+ coord_flip() misspelling %&gt;% ggplot(aes(correct))+ geom_bar(fill = &quot;navy&quot;)+ coord_flip() The same argument could be use in the aes() function: misspelling %&gt;% ggplot(aes(correct, fill = correct))+ geom_bar()+ coord_flip() 4.2.2.1 Factors All variables in the previous section are ordered alphabetically. In order to create your own orders we need to look at factors: my_factor &lt;- factor(misspelling$correct) head(my_factor) ## [1] deschanel deschanel deschanel deschanel deschanel deschanel ## 15 Levels: deschanel galifianakis johansson kaepernick labeouf ... shyamalan levels(my_factor) ## [1] &quot;deschanel&quot; &quot;galifianakis&quot; &quot;johansson&quot; &quot;kaepernick&quot; &quot;labeouf&quot; ## [6] &quot;macaulay&quot; &quot;mcconaughey&quot; &quot;mcgwire&quot; &quot;mclachlan&quot; &quot;minaj&quot; ## [11] &quot;morissette&quot; &quot;palahniuk&quot; &quot;picabo&quot; &quot;poehler&quot; &quot;shyamalan&quot; levels(my_factor) &lt;- rev(levels(my_factor)) head(my_factor) ## [1] shyamalan shyamalan shyamalan shyamalan shyamalan shyamalan ## 15 Levels: shyamalan poehler picabo palahniuk morissette minaj ... deschanel misspelling %&gt;% mutate(correct = factor(correct, levels = c(&quot;deschanel&quot;, &quot;galifianakis&quot;, &quot;johansson&quot;, &quot;kaepernick&quot;, &quot;labeouf&quot;, &quot;macaulay&quot;, &quot;mcgwire&quot;, &quot;mclachlan&quot;, &quot;minaj&quot;, &quot;morissette&quot;, &quot;palahniuk&quot;, &quot;picabo&quot;, &quot;poehler&quot;, &quot;shyamalan&quot;, &quot;mcconaughey&quot;))) %&gt;% ggplot(aes(correct))+ geom_bar()+ coord_flip() There is a package forcats for factors (it is in tidyverse, here is a cheatsheet). There are a lot of useful functions in forcats, but the one I use the most is the fct_reorder() function: misspelling %&gt;% count(correct) misspelling %&gt;% count(correct) %&gt;% ggplot(aes(fct_reorder(correct, n), n))+ geom_col()+ coord_flip() There is an article on Pudding about English pubs. Here is an aggregated dataset, that they used. Visualise the 30 most popular pub‚Äôs names in UK. üìã list of hints ‚û° üëÅ How to get this counts? ‚û° Use the count function. üëÅ Why there are so many values? ‚û° In the task I asked you to take only 30 of them. Maybe you need the slice() function in order to do it. üëÅ Why there are pubs with count 1 on my graph?. ‚û° By default the count function does not sort anything, so you get only pubs with frequency 1 from the slice() function. In order to sort your values you need to use the arrange() function or use an additional sort = TRUE argument in the count() function. üëÅ It looks like I‚Äôve finished. ‚û° Have you removed your x and y axes‚Äô annotation? Have you added the caption? 4.3 Faceting Faceting ‚Äì is a really powerful tool for data exploration. This function splits visualisations into subplots using some variables. misspelling %&gt;% filter(count &gt; 500) %&gt;% ggplot(aes(fct_reorder(spelling, count), count))+ geom_col()+ coord_flip() misspelling %&gt;% filter(count &gt; 500) %&gt;% ggplot(aes(fct_reorder(spelling, count), count))+ geom_col()+ coord_flip()+ facet_wrap(~correct) By default facet_wrap() creates the same scale for all facets. This could be changed by argument scales: misspelling %&gt;% filter(count &gt; 500) %&gt;% ggplot(aes(fct_reorder(spelling, count), count))+ geom_col()+ coord_flip()+ facet_wrap(~correct, scales = &quot;free&quot;) It is also possible to add multiple variables: diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_wrap(~color+cut, scales = &quot;free&quot;) There is a way to make it more compact using the facet_grid() function instead of the facet_wrap() function: diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_grid(cut~color, scales = &quot;free&quot;) It is also possible to create a marginal summary with the margins argument of the facet_grid() function : diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_grid(cut~color, scales = &quot;free&quot;, margins = TRUE) Use the polish_dictionary and reproduce the following graph. References "],
["stringr.html", "5 Strings manipulation: stringr 5.1 How to create a string? 5.2 Merging strings 5.3 Analysing strings 5.4 Changing strings", " 5 Strings manipulation: stringr We will use stringr package (in tidyverse) for string manipulation, so do not forget to load the tidyverse library. library(tidyverse) 5.1 How to create a string? In order to create a string you need to keep an eye on quotes: &quot;the quick brown fox jumps over the lazy dog&quot; ## [1] &quot;the quick brown fox jumps over the lazy dog&quot; &#39;the quick brown fox jumps over the lazy dog&#39; ## [1] &quot;the quick brown fox jumps over the lazy dog&quot; &quot;the quick &#39;brown&#39; fox jumps over the lazy dog&quot; ## [1] &quot;the quick &#39;brown&#39; fox jumps over the lazy dog&quot; &#39;the quick &quot;brown&quot; fox jumps over the lazy dog&#39; ## [1] &quot;the quick \\&quot;brown\\&quot; fox jumps over the lazy dog&quot; &quot;the quick \\&quot;brown\\&quot; fox jumps over the lazy dog&quot; ## [1] &quot;the quick \\&quot;brown\\&quot; fox jumps over the lazy dog&quot; There is also an empty string (it is not the same as NA): &quot;&quot; ## [1] &quot;&quot; &#39;&#39; ## [1] &quot;&quot; character(3) ## [1] &quot;&quot; &quot;&quot; &quot;&quot; It is possible to convert something to a string: typeof(4:7) ## [1] &quot;integer&quot; as.character(4:7) ## [1] &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; In this section I will show all examples using build-in datasets: letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; month.abb ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; 5.2 Merging strings The function str_c() joins two or more vectors element-wise into a single character vector: tibble(upper = rev(LETTERS), smaller = letters) %&gt;% mutate(merge = str_c(upper, smaller)) It is possible to specify a string, that will be inserted between input vectors. tibble(upper = rev(LETTERS), smaller = letters) %&gt;% mutate(merge = str_c(upper, smaller, sep = &quot;_&quot;)) The str_c() function is vectorised, so it returns the number of strings that it got to the input. It is possible to merge all merged strings into one bigger string using the collapse argument. str_c(rev(LETTERS), letters, sep = &quot;_&quot;) # results 26 strings ## [1] &quot;Z_a&quot; &quot;Y_b&quot; &quot;X_c&quot; &quot;W_d&quot; &quot;V_e&quot; &quot;U_f&quot; &quot;T_g&quot; &quot;S_h&quot; &quot;R_i&quot; &quot;Q_j&quot; &quot;P_k&quot; &quot;O_l&quot; ## [13] &quot;N_m&quot; &quot;M_n&quot; &quot;L_o&quot; &quot;K_p&quot; &quot;J_q&quot; &quot;I_r&quot; &quot;H_s&quot; &quot;G_t&quot; &quot;F_u&quot; &quot;E_v&quot; &quot;D_w&quot; &quot;C_x&quot; ## [25] &quot;B_y&quot; &quot;A_z&quot; str_c(rev(LETTERS), letters, sep = &quot;_&quot;, collapse = &quot;-&quot;) # results 1 string ## [1] &quot;Z_a-Y_b-X_c-W_d-V_e-U_f-T_g-S_h-R_i-Q_j-P_k-O_l-N_m-M_n-L_o-K_p-J_q-I_r-H_s-G_t-F_u-E_v-D_w-C_x-B_y-A_z&quot; The separate() function turns a single character column into multiple columns using some pattern. This function has three arguments: col ‚Äì column with vectors, that should be separated into ‚Äì vector of names of new columns sep ‚Äì pattern that should be used as a separator tibble(mn = month.name) %&gt;% separate(col = mn, into = c(&quot;column_1&quot;, &quot;column_2&quot;), sep = &quot;r&quot;) 5.3 Analysing strings In order to calculate the number of symbols in a string you can use the str_count() function. tibble(mn = month.name) %&gt;% mutate(number_charactars = str_count(mn)) There is an additional argument in the str_count() function that defines a string for counting: tibble(mn = month.name) %&gt;% mutate(number_r = str_count(mn, pattern = &quot;r&quot;)) There is an article on Pudding about English pubs. Here is an aggregated dataset, that they used. Visualise 40 most popular pub names in UK: number of symbols on x axis and number of pubs with this name on y axis. There is also a useful function str_detect(), that returns TRUE, when a substring is found in a greater string, or FALSE, when a substring is absent. tibble(mn = month.name) %&gt;% mutate(is_there_r = str_detect(mn, pattern = &quot;r&quot;)) 5.4 Changing strings 5.4.1 Convert case latin &lt;- &quot;tHe QuIcK BrOwN fOx JuMpS OvEr ThE lAzY dOg&quot; str_to_upper(latin) ## [1] &quot;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&quot; str_to_lower(latin) ## [1] &quot;the quick brown fox jumps over the lazy dog&quot; str_to_title(latin) ## [1] &quot;The Quick Brown Fox Jumps Over The Lazy Dog&quot; 5.4.2 Extracting a substring from a string Extract the substring from a string: –ø–æ –∏–Ω–¥–µ–∫—Å–∞–º —Ñ—É–Ω–∫—Ü–∏–µ–π str_sub(), –∏ –ø–æ –ø–æ–¥—Å—Ç—Ä–æ–∫–µ —Ñ—É–Ω–∫—Ü–∏–µ–π str_extract(). tibble(mn = month.name) %&gt;% mutate(mutate = str_sub(mn, start = 1, end = 2)) tibble(mn = month.name) %&gt;% mutate(mutate = str_extract(mn, &quot;r&quot;)) By default the str_extract() function returns first instances of substrings. It is possible to use the str_extract_all() function in order to extract all instances of a substring, but the result needs to be converted to the tibble format. str_extract_all(month.name, &quot;r&quot;, simplify = TRUE) %&gt;% as_tibble() 5.4.3 Replacing a substring There is a function str_replace(), that will replace a substring in a string with another string: tibble(mn = month.name) %&gt;% mutate(mutate = str_replace(mn, &quot;r&quot;, &quot;R&quot;)) As other functions the str_replace() function makes only one replacement. If you need to change multiple substrings in a string you can use the str_replace_all() function: tibble(mn = month.name) %&gt;% mutate(mutate = str_replace_all(mn, &quot;r&quot;, &quot;R&quot;)) 5.4.4 Removing substrings The str_remove() and str_remove_all() functions remove matched patterns in a string. tibble(month.name) %&gt;% mutate(mutate = str_remove(month.name, &quot;r&quot;)) tibble(month.name) %&gt;% mutate(mutate = str_remove_all(month.name, &quot;r&quot;)) "],
["texts.html", "6 Text manipulations 6.1 read_lines() 6.2 gutenbergr 6.3 tidytext 6.4 udpipe 6.5 stylo", " 6 Text manipulations I will still use a lot of tidyverse: library(tidyverse) 6.1 read_lines() If you want to read text in R you can use the read_lines() function: tajemnica_baskerville &lt;- read_lines(&quot;https://raw.githubusercontent.com/agricolamz/2020.02_Naumburg_R/master/data/tajemnica_baskerville.txt&quot;) As a result you will get a vector with characters. It is easy to convert it to dataframe: tibble(text = tajemnica_baskerville) 6.2 gutenbergr The gutenbergr package is an API for a very old project Gutenberg, that is a library of over 60,000 free eBooks. library(gutenbergr) The most important part of this package is the gutenberg_metadata dataset ‚Äì that is a catalogue of everything in the Gutenberg library. str(gutenberg_metadata) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 51997 obs. of 8 variables: ## $ gutenberg_id : int 0 1 2 3 4 5 6 7 8 9 ... ## $ title : chr NA &quot;The Declaration of Independence of the United States of America&quot; &quot;The United States Bill of Rights\\r\\nThe Ten Original Amendments to the Constitution of the United States&quot; &quot;John F. Kennedy&#39;s Inaugural Address&quot; ... ## $ author : chr NA &quot;Jefferson, Thomas&quot; &quot;United States&quot; &quot;Kennedy, John F. (John Fitzgerald)&quot; ... ## $ gutenberg_author_id: int NA 1638 1 1666 3 1 4 NA 3 3 ... ## $ language : chr &quot;en&quot; &quot;en&quot; &quot;en&quot; &quot;en&quot; ... ## $ gutenberg_bookshelf: chr NA &quot;United States Law/American Revolutionary War/Politics&quot; &quot;American Revolutionary War/Politics/United States Law&quot; NA ... ## $ rights : chr &quot;Public domain in the USA.&quot; &quot;Public domain in the USA.&quot; &quot;Public domain in the USA.&quot; &quot;Public domain in the USA.&quot; ... ## $ has_text : logi TRUE TRUE TRUE TRUE TRUE TRUE ... ## - attr(*, &quot;date_updated&quot;)= Date, format: &quot;2016-05-05&quot; How many languages are presented in the Gutenberg library? gutenberg_metadata %&gt;% count(language, sort = TRUE) How many authors are availible? gutenberg_metadata %&gt;% count(author, sort = TRUE) How many Polish texts are availible? gutenberg_metadata %&gt;% filter(language == &quot;pl&quot;) %&gt;% count(author, sort = TRUE) Whose texts are the most numerous in the German part of the Gutenberg library? Put his/her last name in the form. Let‚Äôs have a look at Mickiewicz‚Äôs texts in the Polish part of the Gutenberg library: gutenberg_metadata %&gt;% filter(author == &quot;Mickiewicz, Adam&quot;, language == &quot;pl&quot;) Let‚Äôs download Adam Mickiewicz‚Äôs sonnets: text &lt;- gutenberg_download(27081) text It is possible to use multiple ids. Let‚Äôs also download some poems by A. Mickiewicz (1798‚Äì1855), J. Kochanowski (1530‚Äì1584), Z. Krasinski (1812‚Äì1859), and A. Oppman (1867‚Äì1931): texts &lt;- gutenberg_download(c(27081, 27871, 28009, 27208)) texts Be aware: texts could include something from the real book: introduction or last word written by other people, publication details, etc. texts could be stored with the wrong encoding; texts could be stored with normalised orthography (e. g. Kochanowski, look at rows 99 and 100); texts %&gt;% filter(gutenberg_id == 27208) there are a lot of empty characters; and probably a lot of other problems. I annotated those texts: texts &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020.02_Naumburg_R/master/data/mickiewicz_kochanowski_krasinski_oppman.csv&quot;) Now it is possible to remove some non-important lines: texts %&gt;% filter(title != &quot;remove&quot;) -&gt; texts texts Calculate how many rows per author we do have in our dataset. Who has the largest amount? 6.3 tidytext The tidytext (Silge and Robinson 2017) (this book is available online) allows you to work with texts in tidy ideology, that makes it easier to manipulate, summarize, and visualize the characteristics of texts easily and integrate natural language processing tools (sentiment analysis, tf-idf metric, n-gram analysis, topic modeling etc.). library(tidytext) texts %&gt;% unnest_tokens(output = &quot;word&quot;, input = text) texts %&gt;% unnest_tokens(output = &quot;word&quot;, input = text) %&gt;% group_by(author) %&gt;% count(word, sort = TRUE) %&gt;% top_n(10) %&gt;% ggplot(aes(word, n))+ geom_col()+ coord_flip()+ facet_wrap(~author, scales = &quot;free&quot;) As you see the sorting is bad. Sorting within different facets is possible with the reorder_within() function: texts %&gt;% unnest_tokens(output = &quot;word&quot;, input = text) %&gt;% group_by(author) %&gt;% count(word, sort = TRUE) %&gt;% top_n(10) %&gt;% ggplot(aes(reorder_within(x = word, by = n, within = author), n))+ geom_col()+ coord_flip()+ facet_wrap(~author, scales = &quot;free&quot;) In order to remove the author name you also need to add scale_x_reordered() layer to your ggplot: texts %&gt;% unnest_tokens(output = &quot;word&quot;, input = text) %&gt;% group_by(author) %&gt;% count(word, sort = TRUE) %&gt;% top_n(10) %&gt;% ggplot(aes(reorder_within(word, n, author), n))+ geom_col()+ scale_x_reordered()+ coord_flip()+ facet_wrap(~author, scales = &quot;free&quot;) Often in text analysis, it is useful to remove stop words. Stop words are frequent words that mostly contain grammatic information. I will use a polish stopword list from this repository, but you can use any other list or modify the existing one. stopwords &lt;- read_lines(&quot;https://raw.githubusercontent.com/stopwords-iso/stopwords-pl/master/stopwords-pl.txt&quot;) stopwords ## [1] &quot;a&quot; &quot;aby&quot; &quot;ach&quot; &quot;acz&quot; &quot;aczkolwiek&quot; ## [6] &quot;aj&quot; &quot;albo&quot; &quot;ale&quot; &quot;ale≈º&quot; &quot;ani&quot; ## [11] &quot;a≈º&quot; &quot;bardziej&quot; &quot;bardzo&quot; &quot;bez&quot; &quot;bo&quot; ## [16] &quot;bowiem&quot; &quot;by&quot; &quot;byli&quot; &quot;bym&quot; &quot;bynajmniej&quot; ## [21] &quot;byƒá&quot; &quot;by≈Ç&quot; &quot;by≈Ça&quot; &quot;by≈Ço&quot; &quot;by≈Çy&quot; ## [26] &quot;bƒôdzie&quot; &quot;bƒôdƒÖ&quot; &quot;cali&quot; &quot;ca≈Ça&quot; &quot;ca≈Çy&quot; ## [31] &quot;chce&quot; &quot;choƒá&quot; &quot;ci&quot; &quot;ciebie&quot; &quot;ciƒô&quot; ## [36] &quot;co&quot; &quot;cokolwiek&quot; &quot;coraz&quot; &quot;co≈õ&quot; &quot;czasami&quot; ## [41] &quot;czasem&quot; &quot;czemu&quot; &quot;czy&quot; &quot;czyli&quot; &quot;czƒôsto&quot; ## [46] &quot;daleko&quot; &quot;dla&quot; &quot;dlaczego&quot; &quot;dlatego&quot; &quot;do&quot; ## [51] &quot;dobrze&quot; &quot;dokƒÖd&quot; &quot;do≈õƒá&quot; &quot;dr&quot; &quot;du≈ºo&quot; ## [56] &quot;dwa&quot; &quot;dwaj&quot; &quot;dwie&quot; &quot;dwoje&quot; &quot;dzisiaj&quot; ## [61] &quot;dzi≈õ&quot; &quot;gdy&quot; &quot;gdyby&quot; &quot;gdy≈º&quot; &quot;gdzie&quot; ## [66] &quot;gdziekolwiek&quot; &quot;gdzie≈õ&quot; &quot;go&quot; &quot;godz&quot; &quot;hab&quot; ## [71] &quot;i&quot; &quot;ich&quot; &quot;ii&quot; &quot;iii&quot; &quot;ile&quot; ## [76] &quot;im&quot; &quot;inna&quot; &quot;inne&quot; &quot;inny&quot; &quot;innych&quot; ## [81] &quot;in≈º&quot; &quot;iv&quot; &quot;ix&quot; &quot;i≈º&quot; &quot;ja&quot; ## [86] &quot;jak&quot; &quot;jaka≈õ&quot; &quot;jakby&quot; &quot;jaki&quot; &quot;jakich≈õ&quot; ## [91] &quot;jakie&quot; &quot;jaki≈õ&quot; &quot;jaki≈º&quot; &quot;jakkolwiek&quot; &quot;jako&quot; ## [96] &quot;jako≈õ&quot; &quot;je&quot; &quot;jeden&quot; &quot;jedna&quot; &quot;jednak&quot; ## [101] &quot;jednak≈ºe&quot; &quot;jedno&quot; &quot;jednym&quot; &quot;jedynie&quot; &quot;jego&quot; ## [106] &quot;jej&quot; &quot;jemu&quot; &quot;jest&quot; &quot;jestem&quot; &quot;jeszcze&quot; ## [111] &quot;je≈õli&quot; &quot;je≈ºeli&quot; &quot;ju≈º&quot; &quot;jƒÖ&quot; &quot;ka≈ºdy&quot; ## [116] &quot;kiedy&quot; &quot;kierunku&quot; &quot;kilka&quot; &quot;kilku&quot; &quot;kim≈õ&quot; ## [121] &quot;kto&quot; &quot;ktokolwiek&quot; &quot;kto≈õ&quot; &quot;kt√≥ra&quot; &quot;kt√≥re&quot; ## [126] &quot;kt√≥rego&quot; &quot;kt√≥rej&quot; &quot;kt√≥ry&quot; &quot;kt√≥rych&quot; &quot;kt√≥rym&quot; ## [131] &quot;kt√≥rzy&quot; &quot;ku&quot; &quot;lat&quot; &quot;lecz&quot; &quot;lub&quot; ## [136] &quot;ma&quot; &quot;majƒÖ&quot; &quot;mam&quot; &quot;mamy&quot; &quot;ma≈Ço&quot; ## [141] &quot;mgr&quot; &quot;mi&quot; &quot;mia≈Ç&quot; &quot;mimo&quot; &quot;miƒôdzy&quot; ## [146] &quot;mnie&quot; &quot;mnƒÖ&quot; &quot;mogƒÖ&quot; &quot;moi&quot; &quot;moim&quot; ## [151] &quot;moja&quot; &quot;moje&quot; &quot;mo≈ºe&quot; &quot;mo≈ºliwe&quot; &quot;mo≈ºna&quot; ## [156] &quot;mu&quot; &quot;musi&quot; &quot;my&quot; &quot;m√≥j&quot; &quot;na&quot; ## [161] &quot;nad&quot; &quot;nam&quot; &quot;nami&quot; &quot;nas&quot; &quot;nasi&quot; ## [166] &quot;nasz&quot; &quot;nasza&quot; &quot;nasze&quot; &quot;naszego&quot; &quot;naszych&quot; ## [171] &quot;natomiast&quot; &quot;natychmiast&quot; &quot;nawet&quot; &quot;nic&quot; &quot;nich&quot; ## [176] &quot;nie&quot; &quot;niech&quot; &quot;niego&quot; &quot;niej&quot; &quot;niemu&quot; ## [181] &quot;nigdy&quot; &quot;nim&quot; &quot;nimi&quot; &quot;niƒÖ&quot; &quot;ni≈º&quot; ## [186] &quot;no&quot; &quot;nowe&quot; &quot;np&quot; &quot;nr&quot; &quot;o&quot; ## [191] &quot;o.o.&quot; &quot;obok&quot; &quot;od&quot; &quot;ok&quot; &quot;oko≈Ço&quot; ## [196] &quot;on&quot; &quot;ona&quot; &quot;one&quot; &quot;oni&quot; &quot;ono&quot; ## [201] &quot;oraz&quot; &quot;oto&quot; &quot;owszem&quot; &quot;pan&quot; &quot;pana&quot; ## [206] &quot;pani&quot; &quot;pl&quot; &quot;po&quot; &quot;pod&quot; &quot;podczas&quot; ## [211] &quot;pomimo&quot; &quot;ponad&quot; &quot;poniewa≈º&quot; &quot;powinien&quot; &quot;powinna&quot; ## [216] &quot;powinni&quot; &quot;powinno&quot; &quot;poza&quot; &quot;prawie&quot; &quot;prof&quot; ## [221] &quot;przecie≈º&quot; &quot;przed&quot; &quot;przede&quot; &quot;przedtem&quot; &quot;przez&quot; ## [226] &quot;przy&quot; &quot;raz&quot; &quot;razie&quot; &quot;roku&quot; &quot;r√≥wnie≈º&quot; ## [231] &quot;sam&quot; &quot;sama&quot; &quot;siƒô&quot; &quot;skƒÖd&quot; &quot;sobie&quot; ## [236] &quot;sobƒÖ&quot; &quot;spos√≥b&quot; &quot;swoje&quot; &quot;sƒÖ&quot; &quot;ta&quot; ## [241] &quot;tak&quot; &quot;taka&quot; &quot;taki&quot; &quot;takich&quot; &quot;takie&quot; ## [246] &quot;tak≈ºe&quot; &quot;tam&quot; &quot;te&quot; &quot;tego&quot; &quot;tej&quot; ## [251] &quot;tel&quot; &quot;temu&quot; &quot;ten&quot; &quot;teraz&quot; &quot;te≈º&quot; ## [256] &quot;to&quot; &quot;tobie&quot; &quot;tobƒÖ&quot; &quot;tote≈º&quot; &quot;trzeba&quot; ## [261] &quot;tu&quot; &quot;tutaj&quot; &quot;twoi&quot; &quot;twoim&quot; &quot;twoja&quot; ## [266] &quot;twoje&quot; &quot;twym&quot; &quot;tw√≥j&quot; &quot;ty&quot; &quot;tych&quot; ## [271] &quot;tylko&quot; &quot;tym&quot; &quot;tys&quot; &quot;tzw&quot; &quot;tƒô&quot; ## [276] &quot;u&quot; &quot;ul&quot; &quot;vi&quot; &quot;vii&quot; &quot;viii&quot; ## [281] &quot;vol&quot; &quot;w&quot; &quot;wam&quot; &quot;wami&quot; &quot;was&quot; ## [286] &quot;wasi&quot; &quot;wasz&quot; &quot;wasza&quot; &quot;wasze&quot; &quot;we&quot; ## [291] &quot;wed≈Çug&quot; &quot;wie&quot; &quot;wiele&quot; &quot;wielu&quot; &quot;wiƒôc&quot; ## [296] &quot;wiƒôcej&quot; &quot;wszyscy&quot; &quot;wszystkich&quot; &quot;wszystkie&quot; &quot;wszystkim&quot; ## [301] &quot;wszystko&quot; &quot;wtedy&quot; &quot;www&quot; &quot;wy&quot; &quot;w≈Ça≈õnie&quot; ## [306] &quot;w≈õr√≥d&quot; &quot;xi&quot; &quot;xii&quot; &quot;xiii&quot; &quot;xiv&quot; ## [311] &quot;xv&quot; &quot;z&quot; &quot;za&quot; &quot;zapewne&quot; &quot;zawsze&quot; ## [316] &quot;za≈õ&quot; &quot;ze&quot; &quot;zeznowu&quot; &quot;znowu&quot; &quot;zn√≥w&quot; ## [321] &quot;zosta≈Ç&quot; &quot;z≈Ç&quot; &quot;≈ºaden&quot; &quot;≈ºadna&quot; &quot;≈ºadne&quot; ## [326] &quot;≈ºadnych&quot; &quot;≈ºe&quot; &quot;≈ºeby&quot; So now we are ready to remove stopwords using the antijoin() function: texts %&gt;% unnest_tokens(output = &quot;word&quot;, input = text) %&gt;% anti_join(tibble(word = stopwords)) %&gt;% # here is the stopwords removal group_by(author) %&gt;% count(word, sort = TRUE) %&gt;% top_n(10) %&gt;% ggplot(aes(reorder_within(word, n, author), n))+ geom_col()+ scale_x_reordered()+ coord_flip()+ facet_wrap(~author, scales = &quot;free&quot;) It is also possible to analyse bigrams texts %&gt;% unnest_tokens(output = &quot;bigrams&quot;, input = text, token = &quot;ngrams&quot;, n = 2) %&gt;% # separate into two seperate columns each part of bigram separate(bigrams, into = c(&quot;word_1&quot;, &quot;word_2&quot;), sep = &quot; &quot;) %&gt;% # filter out those that have stopwords anti_join(tibble(word_1 = stopwords)) %&gt;% anti_join(tibble(word_2 = stopwords)) %&gt;% # merge separate columns into one mutate(bigrams = str_c(word_1, word_2, sep = &quot; &quot;)) %&gt;% group_by(author) %&gt;% count(bigrams) %&gt;% top_n(4) %&gt;% ggplot(aes(reorder_within(bigrams, n, author), n))+ geom_col()+ scale_x_reordered()+ coord_flip()+ facet_wrap(~author, scales = &quot;free&quot;) Since our corpora for each author is really small we can‚Äôt see much (e. g. Mickiewicz no repetitions). If the text will be longer (e. g. long novels), you will be able to get the most important. Lets analyse ‚ÄúTajemnicƒô Baskerville‚Äô√≥w‚Äù: tajemnica &lt;- gutenberg_download(34079) tajemnica %&gt;% unnest_tokens(output = &quot;bigrams&quot;, input = text, token = &quot;ngrams&quot;, n = 2) %&gt;% # separate into two seperate columns each part of bigram separate(bigrams, into = c(&quot;word_1&quot;, &quot;word_2&quot;), sep = &quot; &quot;) %&gt;% # filter out those that have stopwords anti_join(tibble(word_1 = stopwords)) %&gt;% anti_join(tibble(word_2 = stopwords)) %&gt;% # merge separate columns into one mutate(bigrams = str_c(word_1, word_2, sep = &quot; &quot;)) %&gt;% count(bigrams, sort = TRUE) %&gt;% top_n(20) %&gt;% ggplot(aes(fct_reorder(bigrams, n), n))+ geom_col()+ coord_flip() Analyse ‚ÄúPan Tadeusz Czyli Ostatni Zajazd na Litwie‚Äù by A. Mickiewicz. What is the most frequent bigram in this text (remove stopwords)? 6.4 udpipe The udpipe package gives you the ability to get lemmatisation, morphological and syntactic analysis for multiple languages. A tutorial and a list of availible languages can be found here. All models are long to download: library(udpipe) udpipe_download_model(language = &quot;polish-pdb&quot;) Texts for udpipe analyser should have variables named text and doc_id: texts %&gt;% mutate(doc_id = str_c(author, &quot;_&quot;, title)) -&gt; texts_for_udpipe texts_for_udpipe After you downloaded a model and created correct dataframe it is possible to analyse our texts: texts_parsed &lt;- udpipe(x = texts_for_udpipe, object = udpipe_load_model(&quot;polish-pdb-ud-2.4-190531.udpipe&quot;)) texts_parsed texts_parsed What is the most frequent part of speech (upos variable) in our corpora according to the model? 6.5 stylo The stylo package (Eder, Rybicki, and Kestemont 2016) is a package for computational stylistics, authorship attribution, etc. First of all it is possible to use pure frequencies as a features for clustarisation: library(stylo) texts %&gt;% mutate(doc_id = str_c(author, title, sep = &quot;_&quot;)) %&gt;% unnest_tokens(text, output = &quot;word&quot;) %&gt;% count(doc_id, word) %&gt;% group_by(doc_id) %&gt;% mutate(ratio = n/sum(n)) %&gt;% pivot_wider(names_from = doc_id, values_from = ratio, values_fill = list(ratio = 0)) %&gt;% select(-word, -n) -&gt; for_stylo for_stylo Then you can run a clustarisation analysis. stylo(parsed.corpus = for_stylo, gui = FALSE, analysis.type = &quot;CA&quot;) You can run with argumment gui = TRUE, then you will see a graphical interface. It is also possible to use lemmatized via udpipe representation. texts_parsed %&gt;% count(doc_id, lemma) %&gt;% group_by(doc_id) %&gt;% mutate(ratio = n/sum(n)) %&gt;% pivot_wider(names_from = doc_id, values_from = ratio, values_fill = list(ratio = 0)) %&gt;% select(-lemma, -n) -&gt; for_stylo_2 stylo(parsed.corpus = for_stylo_2, gui = FALSE, analysis.type = &quot;CA&quot;) Authorship Verification Classifier: texts %&gt;% mutate(author = ifelse(title == &quot;Sonety I.&quot;, &quot;test_mickiewicz&quot;, author), author = ifelse(title == &quot;Sonety VI.&quot;, &quot;test_mickiewicz&quot;, author), author = ifelse(title == &quot;Sonety XX.&quot;, &quot;test_mickiewicz&quot;, author), author = ifelse(title == &quot;Sonety krymskie XV.&quot;, &quot;test_mickiewicz&quot;, author), author = ifelse(title == &quot;Sonety krymskie III.&quot;, &quot;test_mickiewicz&quot;, author), author = ifelse(title == &quot;THREN XIX.&quot;, &quot;test_kochanowski&quot;, author), author = ifelse(title == &quot;Niewymarzona, a cudowna.&quot;, &quot;test_krasinski&quot;, author), author = ifelse(title == &quot;OWCZAREK.&quot;, &quot;test_oppman&quot;, author), author = ifelse(title == &quot;EMIGRANT.&quot;, &quot;test_oppman&quot;, author)) %&gt;% unnest_tokens(output = &quot;word&quot;, input = text) %&gt;% count(author, word, sort = TRUE) %&gt;% filter(n &gt; 1) %&gt;% group_by(author) %&gt;% mutate(ratio = n/sum(n)) %&gt;% select(-n) %&gt;% pivot_wider(names_from = word, values_from = ratio, values_fill = list(ratio = 0)) %&gt;% as.data.frame() -&gt; # stylo package doesn&#39;t work with tibble for_imposter for_imposter Lets choose Krasi≈Ñski: imposters(reference.set = for_imposter[-c(5:8), -c(1:2)], # for some reason this function demands minimum 2 rows in dataframe (contra docs) test = for_imposter[c(5, 5), -c(1:2)], classes.reference.set = for_imposter[-c(5:8), 1]) ## Krasi≈Ñski Mickiewicz Kochanowski Oppman ## 0.00 0.00 0.42 0.92 Lets choose Kochanowski: imposters(reference.set = for_imposter[-c(5:8), -c(1:2)], # for some reason this function demands minimum 2 rows in dataframe (contra docs) test = for_imposter[c(6, 6), -c(1:2)], classes.reference.set = for_imposter[-c(5:8), 1]) ## Krasi≈Ñski Mickiewicz Kochanowski Oppman ## 0.03 0.04 0.28 1.00 Lets choose Mickiewicz: imposters(reference.set = for_imposter[-c(5:8), -c(1:2)], # for some reason this function demands minimum 2 rows in dataframe (contra docs) test = for_imposter[c(7, 7), -c(1:2)], classes.reference.set = for_imposter[-c(5:8), 1]) ## Krasi≈Ñski Mickiewicz Kochanowski Oppman ## 0.05 0.01 0.23 1.00 Lets choose Oppman: imposters(reference.set = for_imposter[-c(5:8), -c(1:2)], # for some reason this function demands minimum 2 rows in dataframe (contra docs) test = for_imposter[c(8, 8), -c(1:2)], classes.reference.set = for_imposter[-c(5:8), 1]) ## Krasi≈Ñski Mickiewicz Kochanowski Oppman ## 0.00 0.00 0.37 1.00 As you see, this algorithm did not work on this verse dataset, but in docs (?imposters()) you can find an example of analysis of the novel ‚ÄúCuckoo‚Äôs Calling‚Äù by a mysterious Robert Galbraith that turned out to be J.K. Rowling. References "],
["references.html", "References", " References "]
]
